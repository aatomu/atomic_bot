//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM"""""` `` `` `` `` 7""""MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMY""!` `` ``` ` ` ` `  ` `````` `` .""TMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@"^` `  ` ` ` `  `` `` ` `` `   `  ` `` ` ` `,"WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMM#"=` `` ` `` ` ` ` ``  ` ` `` `` `` `` ``  `` `` ``` ?"MMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMM""` ` ` ` `` `` `` ` `` ``  ` `  ` ` `  `  `   `   ` ```` ?"MMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMM""` ` ` ` ` ` `  ` ` ` `  `` `` ` `` ` `  `  ` ``  ` ` `  ` ````7"MMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMM" ` `` `` `` ` ` `` ` ` ` ``  ` `` ` `` ` `` ``  ` `` ` ` ` ` `  ``  "MMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMY"``` ` ` ` ` `` `` ` ` `` ` `` ``  ``  ` ``  `  ` ` `  ` ` ``` ` ` ` ``` "7MMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMP!```  ` ` ` ` `` ` `` ` ` `` `  `` `` `` ` ` `  `  ` `` ` `` ` ` `` `     ` `.TMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMM%``  `` `` `` ``.g2`  ` `` `  ` ``  ` `  `` ` ` `` ` ` ` `` ` `.g/` `` `` `  `` `,MMMMMMMMMMMMMM
//MMMMMMMMMMMMF'` ` ` `` ` ` ``.gMN2`` ` ` `` ` `` `` `` ` ` ``  `  ` ` ` `` `.dMN;` `  `` ` ` ` `.4MMMMMMMMMMMM
//MMMMMMMMMMF^``` `` `  ` ` ` .gMMMNc`` ` ` `` `  ``  ` ` ` ` ``  ` ` `` ` ``.dMMMN, ``  ` `` ` ` ``,4MMMMMMMMMM
//MMMMMMMMMF^  ` `  ` `` ` ``.gMMMMMNc`` ` ` ` `` ` `` ` ` ``  ` ` `   ` ` `.dMMMMMN,`` ` ` `  ` `   ,UMMMMMMMMM
//MMMMMMMMF`` ` `` ` ` `` ` .gMMMMMMMN;`` ` ` ` `` ` `` `` ` `` ` ` `` `` `.dMMMMMMMN- `` `` ` `  ` `` JMMMMMMMM
//MMMMMM#^` `` ` `` `  ` ``.gMMMMMMMMMN; ` ` `  ` ` `  ` ` `` `  `  ` ` ``.gMMMMMMMMMN-` ` `` ` ` `  ```(HMMMMMM
//MMMMM#^` `  ` `  ` `` ` .gMMMMMMMMMMMN<`` ``` `` `` `` `  ` `` ``  ` ` .gMMMMMMMMMMMN_``  `  ` ` ` `  `~MMMMMM
//MMMM#^``  `  ` `` ` ``  gMMMMMMMMMMMMMN-``  `` ` ` ` `` `` ` ` ```` ``.gMMMMMMMMMMMMMN_ `` ``  `  `` ` `?MMMMM
//MMM#!` ` `` `` `` ``   gMMMMMMMMMMMMMMMN- ``  ` ` ` `  ` `` ` `  ` ` .gMMMMMMMMMMMMMMMN ` ``  ` `  `` `` ?MMMM
//MMM@` ``  `  `  ` ````gMMMMMMMMMMMMMMMMMN_` `` ` `` `` `  ` `` ` `` .gMMMMMMMMMMMMMMMMMg`` ` ` ` ` ` ` ```MMMM
//MMN `` ` ` ` `` ``  `gMMMMMMMMMMMMMMMMMMMN.` `` ` `  `` `` ` `` ``  gMMMMMMMMMMMMMMMMMMMm ` ` ` ` ` ` `  ` MMM
//MM!`  ``  ` `  ` ` `gMMMMMMMMMMMMMMMMMMMMMN `  `` `` ` ` `` `  ` ` NMMMMMMMMMMMMMMMMMMMMMm``  `  ` ` `  `  ?MM
//MN `` `` `  ` `` ``qMMMMMMMMMMMMMMMMMMMMMMMN`` ` ` `` ` ` ` `` `` NMMMMMMMMMMMMMMMMMMMMMMMm` ` `  `  ` ` ` `MM
//M!` ` ` ` `` ` `  `????????????????????????? ``.NNNNNNNNNNNNNN-` `????????????????????????! `  `` ` ` ` ` ``?M
//M` ` ` `  `  ` `` ``` `  `  `  `  `  `` `` `` .NMMMMMMMMMMMMMMN_` `` `  `  `  `  `  ` `  `` ` `  ` ` `  `  ` M
//M`` ` `` ` `  ` `  ` ` `  `` ` `` ``  `  ` ` `.MMMMMMMMMMMMMMMM!`  `  `  `  `  `  `  ` `  `  ` `  `  ` ` ` ``M
//` `` ` `` ` `` ` `  ` ``` `` ` ` ` ``` ` `` ` .MMMMMMMMMMMMMMMM!`` ` ` `` `` `` `` ``  ``  ` `  `` `  ` `  ```
//` ` ` `  `  ` ` ` `` `  `  `  ` ` `  `` ` ` ` .MMMMMMMMMMMMMMMM!` ``  `  `  `  `  `  `  ` ` ` ` `  `` `  `  `
// ` ` `` ` `  ` `` ` `` ` `` `` `` ``  `` ` `` .MMMMMMMMMMMMMMMM!`  ` ` `  `  `  `  ` ``  ` ` ` `  `  ` ` `` `
// ` `  ` ` `` `  `  `  ` ` `  ` ` ` `` `  `` ` .MMMMMMMMMMMMMMMM!`` ` ` `` `` `` `` `  ` `  `  ` `` `  ` `  ` `
//`  ` `  `  ` `` ` ` `` `  ``  ` `  ` `` ` ` ``.MMMMMMMMMMMMMMMM!`` `  `  `  `  `  ` `  ` `  ` `   ` ` `  `  `
// ` ` `` ` `  ` `` ` ` ` ` `` `` `` `` `` ` ` `.MMMMMMMMMMMMMMMM!` `` `  `  `  `  ` ` ` ` `` `  ` ` ` ` ` ``  `
//` ``  `` ` `  `  ` `` `` ` ` ` ` ` `  `  `` ` .MMMMMMMMMMMMMMMM!` ` ` `` `` `` ``  `` ` `  ` `` `` `  ` `  ``
//N`` `` `  ` `` ``` `....NNNNNNNNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNN-...`` `` ` ` ` `  ` ``N
//M `` ` `` `  ` ``.dNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNN,` ` ` ` ` ` ` ``M
//M. ` ``  ` ` `  `dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM# `` ``  `  ` ``.M
//MN``  ``  ` ` `` dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#` `` `` `` `  `MM
//MN.` ` `` `  ` ``dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#` `  ` ` `` ``.MM
//MMN `` ` ` ` `  `dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#``  ` ` ` `` `MMM
//MMM# `` ` ` ` ` `dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM# `` `` ` ``` dMMM
//MMMN, `` ` ` ``` dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#` `` ` ``  `.MMMM
//MMMMN,` ` `` ` ` dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#``  ` ` ` `.dMMMM
//MMMMMN,` `` ` ` `TMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM5 `` `` ` `.dMMMMM
//MMMMMMN,` `` ``` `MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#`  `` ` ``.dMMMMMM
//MMMMMMMMF` `  ` ` MMMMMMMMMMMMMMMM]`` `` ` ` ` ` ` ` ` ` ` ` `  `  ` `` `` ,MMMMMMMMMMMMMMM#` ` ` `` JMMMMMMMM
//MMMMMMMMMh,`` ` ``MMMMMMMMMMMMMMMM]` `  ` ` ` ` ` ` ` ` ` ` ` `  `  `  `  `,MMMMMMMMMMMMMMM# `` `` .(MMMMMMMMM
//MMMMMMMMMMh, ``  `MMMMMMMMMMMMMMMM] ` `` `` `` `` `` `` `` `` `` ``  `` `` ,MMMMMMMMMMMMMMM#` ``  .(MMMMMMMMMM
//MMMMMMMMMMMMh,`` `MMMMMMMMMMMMMMMM]`` `` ` `  ` ``  ` ``  ` `   `  ` `  `  ,MMMMMMMMMMMMMMM#`  `.-MMMMMMMMMMMM
//MMMMMMMMMMMMMM]`` MMMMMMMMMMMMMMMM] `  ` ` `` `  `` `  ` `` `` ` ` ` `` ```,MMMMMMMMMMMMMMM#```,MMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMa,`TMMMMMMMMMMMMMM]` `` ` `` ` `` ` ``` ` ` `  ` ` ` ` `` ` `(MMMMMMMMMMMMMM5 ..MMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMa-T"MMMMMMMMMM#t` ` `` `  ` ` `` `  `` ` `` `  `  ` `  ` ` `-WMMMMMMMMMM"5--MMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMM+ ` `` `` `` `` ` ` `` `` ` ` ` ` ` `` `` `` `  `` `` `` `` `` ` ` ` (MMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMM(. `` ` ` ` ` `` ` `` ` `` ` `` ``  ` `   ` ` ` ` `` `  ``` ``` ((MMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMN(,` `` `` ` ` `  ` `  ` ``  ` ` ` ` ` ` ` ` ` `  ` ``  `` .(MMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMN(,`` ` `` ` `` ` `` ` ` `` ` `` `` `  ` ` `` ``` `` .(dMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN(,` `` ` `` ` `` ` ` `` ` ` `  ` `  ` ` `` `.(JMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmJJ,` `` ` ` `` `  ` ` ` `` ```` `.JJJMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM+JJJJ` ` `` ` `` ``(JJJJMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/url"
	"time"

	"log"
	"os"
	"os/signal"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"syscall"

	"github.com/bwmarrin/discordgo"
	"github.com/jonas747/dca"
	"golang.org/x/text/language"
)

type SessionData struct {
	guildID      string
	channelID    string
	vcsession    *discordgo.VoiceConnection
	speech_speed float64
	speech_limit int
	speech_lang  string
	mut          sync.Mutex
}

func GetByGuildID(guildID string) (*SessionData, error) {
	for _, s := range sessions {
		if s.guildID == guildID {
			return s, nil
		}
	}
	return nil, fmt.Errorf("Cant find GuildID")
}

var (
	//å¤‰æ•°å®šç¾©
	prefix   = flag.String("prefix", "", "call prefix")
	token    = flag.String("token", "", "bot token")
	clientID = ""
	sessions = []*SessionData{}
)

func main() {
	//flagå…¥æ‰‹
	flag.Parse()
	fmt.Println("prefix       :", *prefix)
	fmt.Println("token        :", *token)

	//botèµ·å‹•æº–å‚™
	discord, err := discordgo.New()
	if err != nil {
		fmt.Println("Error logging")
	}

	//tokenå…¥æ‰‹
	discord.Token = "Bot " + *token

	//eventãƒˆãƒªã‚¬ãƒ¼è¨­å®š
	discord.AddHandler(onReady)
	discord.AddHandler(onMessageCreate)
	discord.AddHandler(onVoiceStateUpdate)
	discord.AddHandler(onMessageReactionAdd)
	discord.AddHandler(onMessageReactionRemove)

	//èµ·å‹•
	if err = discord.Open(); err != nil {
		fmt.Println(err)
	}
	defer func() {
		if err := discord.Close(); err != nil {
			log.Println(err)
		}
	}()
	//èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
	fmt.Println("Listening...")

	//botåœæ­¢å¯¾ç­–
	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt)
	<-sc
}

//BOTã®æº–å‚™ãŒçµ‚ã‚ã£ãŸã¨ãã«Call
func onReady(discord *discordgo.Session, r *discordgo.Ready) {
	clientID = discord.State.User.ID
	servers := 0
	for _, _ = range discord.State.Guilds {
		servers++
	}
	discord.UpdateStatus(0, *prefix+" help | "+strconv.Itoa(servers)+"å€‹ã®é¯–ã§ç¨¼åƒä¸­")
}

//ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé€ã‚‰ã‚ŒãŸã¨ãã«Call
func onMessageCreate(discord *discordgo.Session, m *discordgo.MessageCreate) {
	//ä¸€æ™‚å¤‰æ•°
	GuildID := m.GuildID
	Guild_tmp, _ := discord.Guild(GuildID)
	Guild := Guild_tmp.Name
	ChannelID := m.ChannelID
	Channel, _ := discord.Channel(ChannelID)
	Message := m.ID
	Content := m.Content
	Author := m.Author.Username
	AuthorID := m.Author.ID

	//è¡¨ç¤º
	log.Print("Guild:\"" + Guild + "\"  Channel:\"" + Channel.Name + "\"  " + Author + ": " + Content)

	//bot èª­ã¿ä¸Šã’ç„¡ã— ã®ãƒã‚§ãƒƒã‚¯
	if m.Author.Bot || strings.HasPrefix(m.Content, ";") {
		return
	}

	switch {
	//TTSé–¢é€£
	case Prefix(Content, "join"):
		if _, err := GetByGuildID(GuildID); err == nil {
			if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
				log.Println(err)
			}
			return
		}
		Join(ChannelID, GuildID, discord, AuthorID, Message)
		return
	case Prefix(Content, "speed "):
		session, err := GetByGuildID(GuildID)
		if err != nil || session.channelID != ChannelID {
			if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
				log.Println(err)
			}
			return
		}
		Speed(session, Content, discord, ChannelID, Message)
		return
	case Prefix(Content, "lang "):
		session, err := GetByGuildID(GuildID)
		if err != nil || session.channelID != ChannelID {
			if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
				log.Println(err)
			}
			return
		}
		Lang(session, Content, discord, ChannelID, Message)
		return
	case Prefix(Content, "limit "):
		session, err := GetByGuildID(GuildID)
		if err != nil || session.channelID != ChannelID {
			if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
				log.Println(err)
			}
			return
		}
		Limit(session, Content, discord, ChannelID, Message)
		return
	case Prefix(Content, "word "):
		Word(Content, GuildID, discord, ChannelID, Message)
		return
	case Prefix(Content, "leave"):
		session, err := GetByGuildID(GuildID)
		if err != nil || session.channelID != ChannelID {
			if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
				log.Println(err)
			}
			return
		}
		Leave(session, discord, ChannelID, Message, true)
		return
		//Pollé–¢é€£
	case Prefix(Content, "poll "):
		Poll(Content, Author, discord, ChannelID, Message)
		return
	//Roleé–¢é€£
	case Prefix(Content, "role "):
		//ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã‚‹ã‹ç¢ºèª
		roleCheck, _ := discord.GuildMember(GuildID, AuthorID)
		roleList, _ := discord.GuildRoles(GuildID)
		for _, role := range roleList {
			if strings.Contains(role.Name, "RoleController") {
				for _, roleHave := range roleCheck.Roles {
					if roleHave == role.ID {
						Role(Content, Author, discord, ChannelID, Message)
						return
					}
				}
			}
		}
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	//help
	case Prefix(Content, "help"):
		Help(discord, ChannelID)
		return
	}

	//èª­ã¿ä¸Šã’
	session, err := GetByGuildID(GuildID)
	if err != nil || session.channelID != ChannelID {
		return
	}
	replace := regexp.MustCompile(*prefix + " once ")
	text := replace.ReplaceAllString(Content, "")
	Speech(session, text)
}

func Prefix(message, check string) bool {
	return strings.HasPrefix(message, *prefix+" "+check)
}

func Join(ChannelID string, GuildID string, discord *discordgo.Session, AuthorID string, Message string) {
	if voiceConection, err := joinUserVoiceChannel(discord, AuthorID); err != nil {
		log.Println("missing join vc")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	} else {
		session := &SessionData{
			guildID:      GuildID,
			channelID:    ChannelID,
			vcsession:    voiceConection,
			speech_speed: 1.5,
			speech_limit: 100,
			speech_lang:  "auto",
			mut:          sync.Mutex{},
		}
		sessions = append(sessions, session)
		if err := discord.MessageReactionAdd(ChannelID, Message, "âœ…"); err != nil {
			log.Println(err)
		}
		Speech(session, "ãŠã¯ãƒ¼")
		return
	}
}

func Speech(session *SessionData, text string) {

	data, _ := os.Open("./dic/" + session.guildID + ".txt")
	defer data.Close()
	scanner := bufio.NewScanner(data)
	for scanner.Scan() {
		tmp := scanner.Text()
		replace := regexp.MustCompile(`,.*`)
		from := replace.ReplaceAllString(tmp, "")
		replace = regexp.MustCompile(`.*,`)
		to := replace.ReplaceAllString(tmp, "")
		replace = regexp.MustCompile(from)
		text = replace.ReplaceAllString(text, to)
	}

	if regexp.MustCompile(`<a:|<:|<@|<#|<@&|http|` + "```").MatchString(text) {
		text = "message skip"
		return
	}

	lang := session.speech_lang
	if lang == "auto" {
		lang = "ja"
		if regexp.MustCompile(`^[a-zA-Z0-9\s.,]+$`).MatchString(text) {
			lang = "en"
		}
	}

	//text cut
	length := len(text)
	if length > session.speech_limit {
		text = string([]rune(text)[:session.speech_limit])
	}

	//æ”¹è¡Œåœæ­¢
	if strings.Contains(text, "\n") {
		replace := regexp.MustCompile(`\n.*`)
		text = replace.ReplaceAllString(text, "")
	}

	//èª­ã¿ä¸Šã’å¾…æ©Ÿ
	session.mut.Lock()
	defer session.mut.Unlock()

	voiceURL := fmt.Sprintf("http://translate.google.com/translate_tts?ie=UTF-8&textlen=32&client=tw-ob&q=%s&tl=%s", url.QueryEscape(text), lang)
	err := playAudioFile(session, voiceURL)
	if err != nil {
		log.Printf("Error:%s voiceURL:%s", err, voiceURL)
		return
	}
	return
}

func joinUserVoiceChannel(discord *discordgo.Session, userID string) (*discordgo.VoiceConnection, error) {
	vs := findUserVoiceState(discord, userID)
	return discord.ChannelVoiceJoin(vs.GuildID, vs.ChannelID, false, true)
}

func findUserVoiceState(discord *discordgo.Session, userid string) *discordgo.VoiceState {
	for _, guild := range discord.State.Guilds {
		for _, vs := range guild.VoiceStates {
			if vs.UserID == userid {
				return vs
			}
		}
	}
	return nil
}

func playAudioFile(session *SessionData, filename string) error {
	if err := session.vcsession.Speaking(true); err != nil {
		return err
	}
	defer session.vcsession.Speaking(false)

	opts := dca.StdEncodeOptions
	opts.CompressionLevel = 0
	opts.RawOutput = true
	opts.Bitrate = 120
	opts.AudioFilter = fmt.Sprintf("atempo=%f", session.speech_speed)

	encodeSession, err := dca.EncodeFile(filename, opts)
	if err != nil {
		return err
	}

	done := make(chan error)
	stream := dca.NewStream(encodeSession, session.vcsession, done)
	ticker := time.NewTicker(time.Second)

	for {
		select {
		case err := <-done:
			if err != nil && err != io.EOF {
				return err
			}
			encodeSession.Truncate()
			return nil
		case <-ticker.C:
			playbackPosition := stream.PlaybackPosition()
			log.Println("Sending Now... : Playback:", playbackPosition)
		}
	}
}

func Speed(session *SessionData, Content string, discord *discordgo.Session, ChannelID string, Message string) {
	tmp := strings.Replace(Content, *prefix+" speed ", "", 1)

	tmp_speed, err := strconv.ParseFloat(tmp, 64)
	if err != nil {
		log.Println("missing chenge string to float64")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	if tmp_speed < 0.5 || 100 < tmp_speed {
		log.Println("missing lowest or highest speed")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	session.speech_speed = tmp_speed
	if err := discord.MessageReactionAdd(ChannelID, Message, "ğŸ”Š"); err != nil {
		log.Println(err)
	}
	return
}

func Lang(session *SessionData, Content string, discord *discordgo.Session, ChannelID string, Message string) {
	tmp := strings.Replace(Content, *prefix+" lang ", "", 1)

	if tmp == "auto" {
		session.speech_lang = "auto"
		return
	}

	_, err := language.Parse(tmp)
	if err != nil {
		log.Println("missing chenge to unknown Language")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	session.speech_lang = tmp
	if err := discord.MessageReactionAdd(ChannelID, Message, "ğŸ—£ï¸"); err != nil {
		log.Println(err)
	}
	return
}

func Limit(session *SessionData, Content string, discord *discordgo.Session, ChannelID string, Message string) {
	tmp := strings.Replace(Content, *prefix+" limit ", "", 1)

	tmp_limit, err := strconv.Atoi(tmp)
	if err != nil {
		log.Println("missing chenge string to int")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	if tmp_limit <= 0 {
		log.Println("missing lowest limit")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}
	session.speech_limit = tmp_limit
	if err := discord.MessageReactionAdd(ChannelID, Message, "ğŸ¥º"); err != nil {
		log.Println(err)
	}
	return
}

func Word(Content string, GuildID string, discord *discordgo.Session, ChannelID string, Message string) {
	tmp := strings.Replace(Content, *prefix+" word ", "", 1)

	if strings.Count(tmp, ",") != 1 {
		log.Println("unknown word")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	//ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã‹ç¢ºèª
	_, err := os.Stat("./dic/" + GuildID + ".txt")
	//ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã‹ã£ãŸã‚‰ä½œæˆ
	if os.IsNotExist(err) {
		_, err = os.Create("./dic/" + GuildID + ".txt")
		if err != nil {
			if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
				log.Println(err)
			}
		}
		return
	}

	//èª­ã¿è¾¼ã¿
	text_tmp, err := ioutil.ReadFile("./dic/" + GuildID + ".txt")
	if err != nil {
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	//textã‚’ã«ãƒ€ãƒ–ã‚ŠãŒãªã„ã‹ã‚’ç¢ºèª&ç½®æ›
	text := string(text_tmp)
	replace := regexp.MustCompile(`,.*`)
	check := replace.ReplaceAllString(tmp, "")
	if strings.Contains(text, check) {
		replace := regexp.MustCompile(`.*` + check + `,.*\n`)
		text = replace.ReplaceAllString(text, "")
	}
	text = text + tmp + "\n"
	//æ›¸ãè¾¼ã¿
	err = ioutil.WriteFile("./dic/"+GuildID+".txt", []byte(text), 0777)
	if err != nil {
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}
	if err := discord.MessageReactionAdd(ChannelID, Message, "ğŸ“„"); err != nil {
		log.Println(err)
	}
	return
}

func Leave(session *SessionData, discord *discordgo.Session, ChannelID string, Message string, Reaction bool) {
	Speech(session, "ã•ã„ãªã‚‰")

	if err := session.vcsession.Disconnect(); err != nil {
		log.Println("missing disconnect")
		if Reaction {
			if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
				log.Println(err)
			}
		}
		return
	} else {
		var ret []*SessionData
		for _, v := range sessions {
			if v.guildID == session.guildID {
				continue
			}
			ret = append(ret, v)
		}
		sessions = ret
		if Reaction {
			if err := discord.MessageReactionAdd(ChannelID, Message, "â›”"); err != nil {
				log.Println(err)
			}
		}
		return
	}
}

func Poll(Content string, Author string, discord *discordgo.Session, ChannelID string, Message string) {
	//è¤‡æ•°?ã‚ã‚‹ã‹ç¢ºèª
	if strings.Contains(Content, ",") == false {
		log.Println("unknown word")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	//é•·ã•ç¢ºèª
	replace := regexp.MustCompile(*prefix + " poll|,$")
	poll := replace.ReplaceAllString(Content, "")
	text := strings.Split(poll, ",")
	//Title+Questionã ã‹ã‚‰-1
	length := len(text) - 1
	if length <= 20 {
		//embedã¨ã‹reactionç”¨ã®ã‚„ã¤
		alphabet := []string{"", "ğŸ‡¦", "ğŸ‡§", "ğŸ‡¨", "ğŸ‡©", "ğŸ‡ª", "ğŸ‡«", "ğŸ‡¬", "ğŸ‡­", "ğŸ‡®", "ğŸ‡¯", "ğŸ‡°", "ğŸ‡±", "ğŸ‡²", "ğŸ‡³", "ğŸ‡´", "ğŸ‡µ", "ğŸ‡¶", "ğŸ‡·", "ğŸ‡¸", "ğŸ‡¹"}
		//embedã®tmpä½œæˆ
		embed := &discordgo.MessageEmbed{
			Type:        "rich",
			Title:       "",
			Description: "",
			Color:       1000,
			Footer:      &discordgo.MessageEmbedFooter{Text: "Poller"},
			Author:      &discordgo.MessageEmbedAuthor{Name: ""},
		}
		//ä½œæˆè€…è¡¨ç¤º
		embed.Author.Name = "create by @" + Author
		//Titleã®è¨­å®š
		embed.Title = text[0]
		//ä¸­èº«ã®è¨­å®š
		Question := ""
		for i := 1; i < len(text); i++ {
			Question = Question + alphabet[i] + " : " + text[i] + "\n"
		}
		embed.Description = Question
		//é€ä¿¡
		message, err := discord.ChannelMessageSendEmbed(ChannelID, embed)
		if err != nil {
			log.Println(err)
		}
		//ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨ä¸­èº«ã®è¨­å®š
		for i := 1; i < len(text); i++ {
			Question = Question + alphabet[i] + text[i] + "\n"
			if err := discord.MessageReactionAdd(ChannelID, message.ID, alphabet[i]); err != nil {
				log.Println(err)
			}
		}
	} else {
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
	}
}

func Role(Content string, Author string, discord *discordgo.Session, ChannelID string, Message string) {
	//è¤‡æ•°?ã‚ã‚‹ã‹ç¢ºèª
	if strings.Contains(Content, ",") == false {
		log.Println("unknown word")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	//roleãŒæŒ‡å®šã•ã‚Œã¦ã‚‹ã‹ç¢ºèª
	if strings.Contains(Content, "<@&") == false {
		log.Println("unknown command")
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
		return
	}

	//é•·ã•ç¢ºèª
	replace := regexp.MustCompile(*prefix + " role|,$")
	role := replace.ReplaceAllString(Content, "")
	text := strings.Split(role, ",")
	//Title+Questionã ã‹ã‚‰-1
	length := len(text) - 1
	if length <= 20 {
		//embedã¨ã‹reactionç”¨ã®ã‚„ã¤
		alphabet := []string{"", "ğŸ‡¦", "ğŸ‡§", "ğŸ‡¨", "ğŸ‡©", "ğŸ‡ª", "ğŸ‡«", "ğŸ‡¬", "ğŸ‡­", "ğŸ‡®", "ğŸ‡¯", "ğŸ‡°", "ğŸ‡±", "ğŸ‡²", "ğŸ‡³", "ğŸ‡´", "ğŸ‡µ", "ğŸ‡¶", "ğŸ‡·", "ğŸ‡¸", "ğŸ‡¹"}
		//embedã®tmpä½œæˆ
		embed := &discordgo.MessageEmbed{
			Type:        "rich",
			Title:       "",
			Description: "",
			Footer:      &discordgo.MessageEmbedFooter{Text: "RoleContoler"},
			Color:       1000,
			Author:      &discordgo.MessageEmbedAuthor{Name: ""},
		}
		//ä½œæˆè€…è¡¨ç¤º
		embed.Author.Name = "create by @" + Author
		//Titleã®è¨­å®š
		embed.Title = text[0]
		//ä¸­èº«ã®è¨­å®š
		Question := ""
		for i := 1; i < len(text); i++ {
			Question = Question + alphabet[i] + " : " + text[i] + "\n"
		}
		embed.Description = Question
		//é€ä¿¡
		message, err := discord.ChannelMessageSendEmbed(ChannelID, embed)
		if err != nil {
			log.Println(err)
		}
		//ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨ä¸­èº«ã®è¨­å®š
		for i := 1; i < len(text); i++ {
			Question = Question + alphabet[i] + text[i] + "\n"
			if err := discord.MessageReactionAdd(ChannelID, message.ID, alphabet[i]); err != nil {
				log.Println(err)
			}
		}
	} else {
		if err := discord.MessageReactionAdd(ChannelID, Message, "âŒ"); err != nil {
			log.Println(err)
		}
	}
}

func Help(discord *discordgo.Session, ChannelID string) {
	//embedã®tmpä½œæˆ
	embed := &discordgo.MessageEmbed{
		Type:        "rich",
		Title:       "BOT HELP",
		Description: "",
		Color:       1000,
	}
	Text := "--TTS--\n" +
		*prefix + " join :VCã«å‚åŠ ã—ã¾ã™\n" +
		*prefix + " speed <é€Ÿåº¦> : èª­ã¿ä¸Šã’é€Ÿåº¦ã‚’å¤‰æ›´ã—ã¾ã™\n" +
		*prefix + " lang <è¨€èª> : èª­ã¿ä¸Šã’è¨€èªã‚’å¤‰æ›´ã—ã¾ã™\n" +
		*prefix + " word <å…ƒ>,<å…ˆ> : è¾æ›¸ã‚’ç™»éŒ²ã—ã¾ã™\n" +
		*prefix + " limit <æ–‡å­—æ•°> : èª­ã¿ä¸Šã’æ–‡å­—æ•°ã®ä¸Šé™ã‚’è¨­å®šã—ã¾ã™\n" +
		*prefix + " leave : VCã‹ã‚‰åˆ‡æ–­ã—ã¾ã™\n" +
		"--Poll--\n" +
		*prefix + " poll <è³ªå•>,<å›ç­”1>,<å›ç­”2>... : è³ªå•ã‚’ä½œæˆã—ã¾ã™\n" +
		"--Role--\n" +
		*prefix + " role <åå‰>,@<ãƒ­ãƒ¼ãƒ«1>,@<ãƒ­ãƒ¼ãƒ«2>... : ãƒ­ãƒ¼ãƒ«ç®¡ç†ã‚’ä½œæˆã—ã¾ã™\n  *RoleControllerã¨ã„ã†åå‰ã®ãƒ­ãƒ¼ãƒ«ãŒã¤ã„ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™"
	embed.Description = Text
	//é€ä¿¡
	if _, err := discord.ChannelMessageSendEmbed(ChannelID, embed); err != nil {
		log.Println(err)
	}
}

//VCã§Join||LeaveãŒèµ·ããŸã¨ãã«Call
func onVoiceStateUpdate(discord *discordgo.Session, v *discordgo.VoiceStateUpdate) {

	tmp := ","
	for _, guild := range discord.State.Guilds {
		for _, vs := range guild.VoiceStates {
			if v.ChannelID == vs.ChannelID && vs.UserID != clientID {
				return
			}
			tmp = tmp + vs.UserID + ","
		}
	}
	if strings.Count(tmp, ",") == 2 {
		session, err := GetByGuildID(v.GuildID)
		if err != nil {
			return
		}
		Leave(session, discord, "", "", false)
	}
}

//ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ ã§Call
func onMessageReactionAdd(discord *discordgo.Session, reaction *discordgo.MessageReactionAdd) {
	//å¤‰æ•°å®šç¾©
	UserID := reaction.UserID
	User_tmp, _ := discord.User(UserID)
	User := User_tmp.Username
	Emoji := reaction.Emoji.Name
	ChannelID := reaction.ChannelID
	Channel, _ := discord.Channel(ChannelID)
	MessageID := reaction.MessageID
	Message_tmp, _ := discord.ChannelMessage(ChannelID, MessageID)
	Message := Message_tmp.Content
	GuildID := reaction.GuildID
	Guild_tmp, _ := discord.Guild(GuildID)
	Guild := Guild_tmp.Name

	//bot ã®ãƒã‚§ãƒƒã‚¯
	botCheck, _ := discord.User(UserID)
	if botCheck.Bot {
		return
	}

	//æ”¹è¡Œã‚ã¨ã‚’å‰Šé™¤
	if strings.Contains(Message, "\n") {
		replace := regexp.MustCompile(`\n.*`)
		Message = replace.ReplaceAllString(Message, "..")
	}

	//ãƒ­ã‚°ã‚’è¡¨ç¤º
	log.Print("Guild:\"" + Guild + "\"  Channel:\"" + Channel.Name + "\"  Message:" + Message + "  User:" + User + "  Add:" + Emoji)

	//è¤‡é…åˆ—ã‚’stringã«å¤‰æ›
	message, _ := discord.ChannelMessage(ChannelID, MessageID)
	text := ""
	for _, embed := range message.Embeds {
		text = text + embed.Description
	}

	//stringã‚’é…åˆ—ã«ã—ã¦1å€‹ãšã¤å‡¦ç†
	for _, embed := range strings.Split(text, "\n") {
		//ãƒ­ãƒ¼ãƒ«è¿½åŠ 
		if strings.HasPrefix(embed, Emoji) {
			replace := regexp.MustCompile(`[^0-9]`)
			RoleID := replace.ReplaceAllString(embed, "")
			err := discord.GuildMemberRoleAdd(GuildID, UserID, RoleID)
			//å¤±æ•—æ™‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡ºã™
			if err != nil {
				log.Print(err)
				//embedã®tmpä½œæˆ
				embed := &discordgo.MessageEmbed{
					Type:        "rich",
					Description: "ãˆã‚‰ãƒ¼ : è¿½åŠ ã§ãã¾ã›ã‚“ã§ã—ãŸ",
					Color:       1000,
				}
				//é€ä¿¡
				if _, err := discord.ChannelMessageSendEmbed(ChannelID, embed); err != nil {
					log.Println(err)
				}
			}
			return
		}
	}
}

//ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‰Šé™¤ã§Call
func onMessageReactionRemove(discord *discordgo.Session, reaction *discordgo.MessageReactionRemove) {
	//å¤‰æ•°å®šç¾©
	UserID := reaction.UserID
	User_tmp, _ := discord.User(UserID)
	User := User_tmp.Username
	Emoji := reaction.Emoji.Name
	ChannelID := reaction.ChannelID
	Channel, _ := discord.Channel(ChannelID)
	MessageID := reaction.MessageID
	Message_tmp, _ := discord.ChannelMessage(ChannelID, MessageID)
	Message := Message_tmp.Content
	GuildID := reaction.GuildID
	Guild_tmp, _ := discord.Guild(GuildID)
	Guild := Guild_tmp.Name

	//bot ã®ãƒã‚§ãƒƒã‚¯
	botCheck, _ := discord.User(UserID)
	if botCheck.Bot {
		return
	}

	//æ”¹è¡Œã‚ã¨ã‚’å‰Šé™¤
	if strings.Contains(Message, "\n") {
		replace := regexp.MustCompile(`\n.*`)
		Message = replace.ReplaceAllString(Message, "..")
	}

	//ãƒ­ã‚°ã‚’è¡¨ç¤º
	log.Print("Guild:\"" + Guild + "\"  Channel:\"" + Channel.Name + "\"  Message:" + Message + "  User:" + User + "  Remove:" + Emoji)

	//è¤‡é…åˆ—ã‚’stringã«å¤‰æ›
	message, _ := discord.ChannelMessage(ChannelID, MessageID)
	text := ""
	for _, embed := range message.Embeds {
		text = text + embed.Description
	}

	//stringã‚’é…åˆ—ã«ã—ã¦1å€‹ãšã¤å‡¦ç†
	for _, embed := range strings.Split(text, "\n") {
		//ãƒ­ãƒ¼ãƒ«è¿½åŠ 
		if strings.HasPrefix(embed, Emoji) {
			replace := regexp.MustCompile(`[^0-9]`)
			RoleID := replace.ReplaceAllString(embed, "")
			err := discord.GuildMemberRoleRemove(GuildID, UserID, RoleID)
			//å¤±æ•—æ™‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡ºã™
			if err != nil {
				log.Print(err)
				//embedã®tmpä½œæˆ
				embed := &discordgo.MessageEmbed{
					Type:        "rich",
					Description: "ãˆã‚‰ãƒ¼ : å‰Šé™¤ã§ãã¾ã›ã‚“ã§ã—ãŸ",
					Color:       1000,
				}
				//é€ä¿¡
				if _, err := discord.ChannelMessageSendEmbed(ChannelID, embed); err != nil {
					log.Println(err)
				}
			}
			return
		}
	}
}
